bool is_error = false;


postfix_expression '.' :

        //3AC
		// Todo -> $$->type
        std::string temp_var = getTempVariable("int*"); // TODO : need to confirm type
		// $$->nextlist.clear();
		// TODO : replace std::string($3) with $3->offset
		emit("unary&", $1->place, "", temp_var, -1);
		emit("ptr+", temp_var, std::string($3), temp_var, -1);
		temp_var = "*" + temp_var;
        $$->place = temp_var;
        // emit("member_access", $1->place, std::string($3), temp_var, -1); changed from this


    | postfix_expression PTR_OP IDENTIFIER {
        $$ = getNode($2, mergeAttrs($1, getNode($3)));

        //3AC
		// Todo $$ -> type
		std::string temp_var = getTempVariable("int*"); // TODO : need to confirm type
		// TODO : replace std::string($3) with $3->offset
		emit("ptr+", $1->place, std::string($3), temp_var, -1);
		temp_var = "*" + temp_var;
		$$->place = temp_var;
		//emit("PTR_OP", $1->place, std::string($3), temp_var, -1);
    }
	| postfix_expression '.' IDENTIFIER '(' ')' {
		// handle ast, symtable and semantic checks
		// $$ = $1;
        //3AC
		$$->temp_name = $3;
		// $$->nextlist.clear();
		std::string p = getTempVariable("int"); // TODO : type = CLASS *
		emit("unary&", $1->place, "", p, -1);
		emit("param", p, "", "", -1); // push ptr to object
		std::string q = getTempVariable("int"); // TODO : type = type of return value
		emit ("CALL", $$->temp_name, "1", q, -1);
		$$->place = q;
    }
	| postfix_expression '.' IDENTIFIER '(' argument_expression_list ')' {
        // handle ast, symtable and semantic checks
		// $$ = getNode("postfix_expression", mergeAttrs($1, $3));
        //3AC
		$$->temp_name = $3;
		// $$->nextlist.clear();
		std::string p = getTempVariable("int"); // TODO : type = CLASS *
		emit("unary&", $1->place, "", p, -1);
		emit("param", p, "", "", -1); // push ptr to object
		std::string q = getTempVariable("int"); // TODO : type = type of return value
		emit ("CALL", $$->temp_name, std::to_string($5->argCount + 1), q, -1);
		$$->place = q;
    }
	| postfix_expression PTR_OP IDENTIFIER '(' ')' {
        // handle ast, symtable and semantic checks
		// $$ = $1;
        //3AC
		$$->temp_name = $3;
		// $$->nextlist.clear();
		emit("param", $1->place, "", "", -1); // push ptr to object
		std::string q = getTempVariable("int"); // TODO : type = type of return value
		emit ("CALL", $$->temp_name, "1", q, -1);
		$$->place = q;
    }
	| postfix_expression PTR_OP IDENTIFIER '(' argument_expression_list ')' {
        // handle ast and symtable
		// $$ = getNode("postfix_expression", mergeAttrs($1, $3));
        //3AC
		$$->temp_name = $3;
		// $$->nextlist.clear();
		emit("param", $1->place, "", "", -1); // push ptr to object
		std::string q = getTempVariable("int"); // TODO : type = type of return value
		emit ("CALL", $$->temp_name, std::to_string($5->argCount + 1), q, -1);
		$$->place = q;
    }	




    | unary_operator cast_expression { //TODO: l value .. Here
        $$ = getNode("unary_exp", mergeAttrs($1, $2));
		if(DEBUG) {
			std::cerr << '\n' << line << '\n';
			std::cerr << "Unary Expression 260: "<< $2->type << ' ' << $1->place << ' ' << $2->place << ' ' << arr_rValue << std::endl;
		}
        //3AC
		if($1->place == "unary*"){
			// Reduce one level of pointer indirection for $$->type
			if($2->type.back() == '*') {
				$$->type = $2->type.substr(0, $2->type.size() - 1);
			} else {
				yyerror("syntax error, Invalid dereference of non-pointer type");
				$$->type = "ERROR";
			}
		} else if($1->place == "unary&") {
			// Add one level of pointer indirection for $$->type
			$$->type = $2->type + "*";
		}else{
			$$->type = $2->type;
		}

		if(arr_rValue == 0 && $2->type == "int*"){ // (*ptr) = 10 -> ptr store 10 
			$$->temp_name = $2->temp_name;
			$$->place = "*" + $2->place;
			$$->nextlist.clear();
		}else{
			std::string q = getTempVariable($2->type);
			$$->temp_name = $2->temp_name;
			$$->place = q;
			$$->nextlist.clear();
			emit($1->place, $2->place, "", q, -1);
		}
    }