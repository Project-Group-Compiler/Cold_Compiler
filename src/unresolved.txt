bool is_error = false;

	
    | unary_operator cast_expression { //TODO: l value .. Here
        $$ = getNode("unary_exp", mergeAttrs($1, $2));
		if(DEBUG) {
			std::cerr << '\n' << line << '\n';
			std::cerr << "Unary Expression 260: "<< $2->type << ' ' << $1->place << ' ' << $2->place << ' ' << arr_rValue << std::endl;
		}
        //3AC
		if($1->place == "unary*"){
			// Reduce one level of pointer indirection for $$->type
			if($2->type.back() == '*') {
				$$->type = $2->type.substr(0, $2->type.size() - 1);
			} else {
				yyerror("syntax error, Invalid dereference of non-pointer type");
				$$->type = "ERROR";
			}
		} else if($1->place == "unary&") {
			// Add one level of pointer indirection for $$->type
			$$->type = $2->type + "*";
		}else{
			$$->type = $2->type;
		}

		if(arr_rValue == 0 && $2->type == "int*"){ // (*ptr) = 10 -> ptr store 10 
			$$->temp_name = $2->temp_name;
			$$->place = "*" + $2->place;
			$$->nextlist.clear();
		}else{
			std::string q = getTempVariable($2->type);
			$$->temp_name = $2->temp_name;
			$$->place = q;
			$$->nextlist.clear();
			emit($1->place, $2->place, "", q, -1);
		}
    }